# Woofie
Инструмент коллаборативного автоматизированного перевода (CAT-программа)

## Состав группы:
Одинцов Кирилл Сергеевич (гр. 5130904/30106)

Дмитриев Арсений Эдуардович (гр. 5130904/30106)

Засульский Егор Андреевич (гр. 5130904/30106)

Маланьин Никита Александрович (гр. 5130904/30106)

Проселков Станислав Павлович (гр. 5130904/30106)

Горбунова Алена Евгеньевна (гр. 5130904/30106)

## Технологический стек:
- Серверная часть: Java
- Базы данных: PostgreSQL
- Внешние зависимости: интеграция с сервисами машинного перевода (к примеру «Яндекс.Переводчик» с использованием API-ключа)
- UI: Qt 6

## Определение проблемы

Отсутствие открытых CAT-программ позволяющих организовывать проекты в виде дерева. Вместо этого существующие инструменты ограничиваются табличным отображением единиц перевода, что осложняет процесс, когда последовательность текста зависит от конкретных условий (к примеру «деревья диалогов» в видеиграх).

## Основные требования
- Возможность использования древовидной структуры для отображения единиц перевода.

Когда на практике переводимый текст зависит от строго заданных условий, я хочу иметь возможность отражать это структурой единиц перевода в CAT-программе, чтобы не путаться в исключительно последовательном табличном отображении

- Возможность делать запросы в сервисы машинного перевода и проверки правописания.

Когда возникает необходимость сверить смысл или правописание, я хочу использовать быстродоступные сервисы машинного перевода и правописания, чтобы не выбиваться из процесса перевода.

- Возможность редактировать единицы перевода в режиме реального времени.

Когда другой пользователь тем или иным образом изменил единицу перевода, я хочу увидеть это изменение без нужды ручного обновления, чтобы всегда видеть актуальное состояние проекта.

Ожидается, что данным набором инструментов (клиентом и сервером) будут пользоваться команды переводчиков текста, которые обычно являются небольшими, но программы строятся с рассчётом на максимум 10к пользователей в сутки. Как правило проекты завершаются меньше, чем за год, период хранения информации соответствующий.

## Разработка архитектуры и детальное проектирование

### Характер нагрузки
- R/W нагрузка - ожидается более высокая интенсивность чтения. При работе с текстом программа-клиент будет активно производить операции вставки в базу данных, но при этом текст должен автоматически синхронизироваться между всеми клиентами, таким образом чтение каждого нового изменения в базу данных растёт с количеством пользователей.
- Объём трафика - подавляюще большую часть трафика будут занимать текстовые данные единиц перевода, оценить объём можно следующим образом:
    - Одну единицу перевода можно оценить в 1 КиБ (достаточно примерно на 1024 / 2 байта на символ / 4 букв на слово = 128 слов в кодировке UTF-8), один пользователь за рабочую неделю сделает примерно 500 изменений в текст (40 часов * 60 / 5 минут на изменение = 480 изменений) изменений в текст, соответственно количество данных на запись оценивается в 1 КиБ * 500 / 7 = 72 КиБ на пользователя в день. При этом количество данных на чтение дополнительно растёт с количеством пользователей, т.к. каждый пользователь должен иметь доступ к истории изменений.
    - Запись:
        - Типовой случай: 72 КиБ/день * 100 пользователей = 7200 КиБ/день = 7 МиБ/день
        - Худший случай: 72 КиБ/день * 10000 пользователей = 720000 КиБ/день = 700 МиБ/день
    - Чтение:
        - Типовой случай: 7 МиБ/день * 100 пользователей = 700 МиБ/день
        - Худший случай: 7 МиБ/день * 10000 пользователей = 70000 МиБ/день = 70 ГиБ/день
    - На практике количество данных на запись/чтение будет ограничено сверху количеством единиц перевода.
- Объёмы дисковой системы - как в случае с объёмом трафика, большую часть дискового пространства будут занимать текстовые данные; в зависимости от размера проекта количество единиц перевода может превышать десятки, если не сотни тысяч. Как правило одна единица требует не больше двух-трёх итераций (черновой вариант + вычитка), соответственно:
    - Типовой случай: 1 КиБ/ед.п. * 10000 ед.п. * 3 итерации = 30000 КиБ = 29 МиБ
    - Худший случай: 1 КиБ/ед.п. * 100000 ед.п. * 3 итерации = 300000 КиБ = 293 МиБ

## Тестирование

Тестовые запросы http к серверу:
### 1. GET /api/translations (Запрос всех единиц)
\# Ожидаемый статус: 200 OK
\# Ожидаемое тело: { "timestamp": ..., "translations": [...] }
GET http://localhost:8080/api/translations

### 2. POST /api/translations (Добавление единицы)
\# Ожидаемый статус: 201 Created
POST http://localhost:8080/api/translations
Content-Type: application/json

{
  "sourceText": "Hello world",
  "targetText": "Привет мир",
  "connections": [
    { "description": "First connection" }
  ]
}

### 3. POST /api/translations (Ошибка 400 - отсутствует поле)
\# Ожидаемый статус: 400 Bad Request
POST http://localhost:8080/api/translations
Content-Type: application/json

{
  "targetText": "Only target"
}

### 4. GET /api/translations/{id} (Запрос по ID)
\# Ожидаемый статус: 200 OK
GET http://localhost:8080/api/translations/2

### 5. DELETE /api/translations/{id} (Удаление)
\# Ожидаемый статус: 204 No Content
DELETE http://localhost:8080/api/translations/1

### 6. DELETE /api/translations/{id} (Ошибка 404 - уже удалено)
\# Ожидаемый статус: 404 Not Found
DELETE http://localhost:8080/api/translations/1

## Тестирование с нагрузкой

Сервер был протестирован под симулированной нагрузкой с использованием gatling. Испытана нагрузка на сценариях, где в течение минуты или более отправляется 1 тысяча, 5 тысяч и 10 тысяч POST-запросов на /api/translations в секунду. (таблицы вывода приведены в документе курсовой)
Результаты показывают, что нагрузку в 5 тысяч запросов/c и ниже сервер выдерживает без особых трудностей, подавляющее большинство таких запросов получают ответ меньше, чем за секунду. Когда нагрузка достигает 10 тысяч запросов/c - больше половины запросов не получают ответ (92% из них отбрасывает операционная система из-за длинной очереди), а средняя скорость обработки увеличивается до 12 секунд. Учитывая, что даже 1 тысяча запросов в секунду это нереалистично высокая мерка для потенциального пользования данной программы - за её масштабируемость беспокоиться нет необходимости.

## Сборка и запуск
Сборка и запуск

Для сборки клиента используется утилита `cmake`: 
```
cmake -S Woofie -B build
cmake --build build
```

Для упрощения сборки вне контейнера (в частности для подгрузки библиотек и среды разработки QtCreator) можно применить менеджер пакетов и утилиты `nix`:
```
nix develop
```

Предусмотрена сборка через docker:
```
docker build -t buildimage  
```

В отличие от серверной стороны, ввиду того, что клиент является GUI-приложением, его запуск изнутри контейнера затруднён, если не невозможен. 

Для ручного тестирования, сборки и запуска сервера используется `gradle`:
```
gradle test 
gradle build 
gradle bootRun 
```

Для ручного запуска (пустой) базы данных PostgreSQL так же применяется `nix`:
```
nix run 
```

Базу данных и сервер можно собрать и запустить используя `docker-compose`:
```
docker-compose up 
```
